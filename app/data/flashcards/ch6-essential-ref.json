{"cards": [{"answer": "functions\nscoping rules\nclosures\ndecorators\ngenerators\ncoroutives\n(declarative)\nlist comprehensions\ngenerator expressions", "question": "What functional and declarative style programming tools does Python have?"}, {"answer": "Not to use mutable objects.  No, f(x=[]):\u2026", "question": "What must you be careful about regarding default function parameters?"}, {"answer": "None.  Then check if it exists, if not create the object.", "question": "What should you use as a default for mutable objects?"}, {"answer": "Side effects.\nCan lead to subtle bugs as program size/complexity increases.", "question": "What is it called when a function mutates their input values or changes the state of other parts of the program and why should this be avoided/controlled?"}, {"answer": "Using lexical scoping, innermost to outermost enclosing block.", "question": "How are variables in nested functions bound?"}, {"answer": "The statements that make up a function packaged with the environment in which they execute.", "question": "What is a closure?"}, {"answer": "lazy or delayed execution", "question": "What is one use of closures?"}, {"answer": "A closure", "question": "What is a more efficient way to preserve state across function calls then a class?"}, {"answer": "A decorator", "question": "What is the name for a function whose primary purpose is to wrap another function?"}, {"answer": "order listed", "question": "What order are decorators applied in?"}, {"answer": "Yes.\nDecorator should return a class object.", "question": "Can decorators be applied to class definitions?\nWhat is the difference from function decorators?"}, {"answer": "The yield keyword.", "question": "What defines a generator object?"}, {"answer": "A function that produces a sequence of values for use in iteration.", "question": "What is a generator?"}, {"answer": "A function that executes in response to data being sent to it.  Place the yield on the right side of the assignment operator.", "question": "What is is a coroutine?"}, {"answer": "next()\nsent(data)", "question": "What must be called to advance to the first yield statement in a coroutine?\nWhat is called after that?"}, {"answer": "yes.", "question": "Can coroutines also emit values?"}, {"answer": "systems, networking, and distributed computation", "question": "What type of programming problems are generators and coroutines particularly effective for?"}, {"answer": "pipe (a processing pipeline)\n(coroutines would be an inverted pipe", "question": "What are generators similar to in unix?\nWhat about coroutines?"}, {"answer": "list comprehension\n[expression for item1 in iterable1 if condition1\n\t          for item2 in iterable2 if condition2\n\t          \u2026]", "question": "What is the name for applying a function to all the items in a list?\nWhat is the syntax?"}, {"answer": "Nested for loops\n:For item1 in iterable1\n:\tIf condition1\n:\t\tFor item2 in iterable2\n:\t\t\t\u2026", "question": "What are list comprehensions roughly equivalent to?"}, {"answer": "No.", "question": "Do sequences supplied to list comprehensions need to be the same length?"}, {"answer": "Yes, but they must be enclosed in parenthesis.", "question": "Can list comprehensions return tuples?"}, {"answer": "Generator expressions perform the same computation as list comprehensions but produce the results iteratively.\nThe syntax is the same except parenthesis are used instead of square brackets.", "question": "What is a generator expression?\nWhat is the syntax?"}, {"answer": "Memory, generator expressions don\u2019t create the whole list immediately, just parts as they are needed.", "question": "What is an advantage of generator expressions over list comprehensions?"}, {"answer": "Declarative languages and mathematical set theory.\nList comp:  [x * x for x in a if x > 0]\nSet theory: {x^2 | x contained in a, x > 0}", "question": "What are list comprehensions and generator expressions related too?"}, {"answer": "1) More compact\n2) Runs faster", "question": "What are two advantages of declarative code?"}, {"answer": "lambda", "question": "What is used to specify short anonymous callback functions?"}, {"answer": "1) There is a limit on the depth of recursive function calls. Default is 1000.\n2) Python does not perform tail recursion optimizations\n3) Care must be taken with generators and recursion, so iterate over them and don\u2019t just create new ones.\n4) All inner recursive calls get passed through decorators", "question": "What four things need to be kept in mind with Python recursion?"}, {"answer": "Propagate the function name and doc string.", "question": "How must decorators be written so as to not break doc strings?"}, {"answer": "Yes.", "question": "Can functions have arbitrary attributes?"}, {"answer": "__dict__", "question": "Where are function attributes stores?"}, {"answer": "value = eval(string)\nexec(string)\ncompile()", "question": "What do you call to execute an expression string and return the results?\nWhat do you call to execute a string of python code?\nWhat can be used to precompile code for the above statements?"}], "title": "Essential Ref Ch. 6"}