{"cards": [{"answer": "Algol", "question": "What other language evolved in parallel with Lisp in the late 1950s?"}, {"answer": "Pascal and C\n(although C differs in significant ways?)", "question": "What are the two most prominent Algol family languages?"}, {"answer": "1) sequence of statements\n2) block structure\n3) functions & procedures\n4) static typing", "question": "What are the four main characteristics of the Algol family?"}, {"answer": "Backus Normal Form (BNF)", "question": "What was an interesting by-product of Algol 60 design?"}, {"answer": "A rich set of data-structuring concepts: records (structs), union type, subranges.", "question": "What was an important contribution of Pascal?"}, {"answer": "Modula (modules)", "question": "Which descendent of Pascal\u2019s main innovation was a grouping sets of related declarations into programming units?"}, {"answer": "Its treatment of memory locations, arrays, and pointers.  Inherited from B where the only data type is a \u2018word\u2019 or \u2018cell,\u2019 a fixed-length bit pattern, and memory is presented to the programmers as a linear array of words.  Thus pointers and arrays are largely equivalent.", "question": "What characteristic most distinguishes C from other popular languages?"}, {"answer": "ML", "question": "Which early language could be considered mostly functional with imperative features or a function-oriented imperative languages, that has concepts from both the Lisp and Algol family of languages?"}, {"answer": "More uniformly, in C and Pascal, function identifiers are constants, whereas other identifiers are assignable.  In ML all declarations are constants (no side effects), but can make them assignable using reference cells, similar to cons cell in lisp.", "question": "How does ML treat identifiers more uniformly that Pascal and C?"}, {"answer": "Tuple and List", "question": "What data-structure types does ML share with Python?"}, {"answer": "Patterns.  The formal parameters are a tuple that must match the unpacked the unpacked actual parameters.  This allows pattern matching\n:fun f(x, 0) = x\n|      f(0, y) = y\n|     f (x, y) = x + y", "question": "What do ML function declarations use?"}, {"answer": "L-value \u2013 location \nR-value \u2013 value stored in that location\nComes from x:= y + 3\nx is on the left side, its value doesn\u2019t matter only its location since the results of the operation are going to be stored there.\ny is on the right side, its location doesn\u2019t matter, only its value which is needed for the operation.", "question": "What are L-value and R-value?"}, {"answer": "uninitialized variables or dangling pointers", "question": "In ML, reference cells must be initialized to a value of the correct type.  What does this prevent?"}, {"answer": "A collection of computational elements (to include data) that share some common property.", "question": "What is a type?"}, {"answer": "1) naming and organizing concepts\n2) ensure correct interpretation of bit sequences in memory\n3) provide info about data to the compiler", "question": "What are the three main uses of types?"}, {"answer": "When a computational entity (function or data) is used in a manner inconsistent with the concept it represents.", "question": "What is a type error?"}, {"answer": "When no program is allowed to violate its type distinctions.\nC is not type safe due to pointers.", "question": "When is a language type safe?  Is C type safe?"}, {"answer": "When every expression has a type and it is type safe.", "question": "When is a language strongly typed?"}, {"answer": "compile-time or run-time\n(many languages use a combination of both)", "question": "At what two times are types checked?"}, {"answer": "Compile-time checks are faster and more conservative, but may restrict program expressiveness.", "question": "What are the tradeoffs between compile-time and run-time type checking?"}, {"answer": "The process of determining the types of expressions based on the known types of symbols that appear in them.  Unlike type-checking, not all information is specified and some must be inferred.", "question": "What is type inference?"}, {"answer": "Place holders for unknown types.  May be resolved to specific types (bool, int, \u2026) by the type-inference algorithm or may not be constrained in such a way by the function definition, so that the function can be applied to any type that matches the form given by the type expression.  Java generics?  (Type inference and polymorphism are independent concepts, but the latter arises from the way type variables are used in the former.)", "question": "What are type variables?"}, {"answer": "1) Assign a type to the expression and each sub expression.\n2) Generate a set of constraints on types. (a system of equations from parse tree)\n3) Solve the constraints via unification. (solve the equations through substitution)", "question": "What are the three steps of the ML type-inference algorithm?"}, {"answer": "&lambda;x.((+5)x)\t- r\n((+5)x)\t\t- s\n(+5)\t\t\t- t\n+\t\t\t- int -> (int -> int)\n  5\t\t\t- int\n    x \t\t\t- u", "question": "What are the sub-expressions and types of g(x) = 5 + x?"}, {"answer": "If type of f is a, type of e is b, and type of fe is c, then a = b -> c\n(think that the type of f must be a for the application of e (to f) with type b to result in type c)", "question": "What is the rule of function application?"}, {"answer": "Well typed", "question": "What is the name for an expression that satisfies all its constraints?"}, {"answer": "That the function is polymorphic and may be used for different types of arguments if they match the type expression.", "question": "What does it mean if there are type variables in the argument?"}, {"answer": "1) Parametric polymorphism (variable argument types to a function)\n2) Ad hoc polymorphism (overloading, two+ implementations with same name)\n3) Subtype polymorphism ", "question": "What are the three forms of polymorphism?"}, {"answer": "1) Implicit (type inference algorithm inserts template)\n2) Explicit (special type variable for describe template)", "question": "What are the two types of parametric polymorphism?"}, {"answer": "transparent \u2013 new name for another type\nopaque \u2013 new type", "question": "What are the two basic forms of type declarations?"}, {"answer": "name & structure", "question": "What are the two forms of type equality?"}, {"answer": "A region of text in which a declaration is visible.  \nA programming language feature that allows two identical names to refer to different things (memory locations)", "question": "What is scope?"}, {"answer": "new memory area to store function parameters and local variables.", "question": "What do scope and function calls both require?"}, {"answer": "A block", "question": "What do most programming languages provide/call a region of text with begin and end markers, that may contain local declarations?"}, {"answer": "Recursive functions", "question": "What do the storage management mechanisms associated with block structure allow?"}, {"answer": "No, but they can be nested.", "question": "Can blocks overlap?"}, {"answer": "Space for local variables declared in the block on the run-time stack.  Also called a stack frame.", "question": "What is an activation record?"}, {"answer": "The current activation record.\nA previous activation record. (the nearest enclosing block with the variable)", "question": "Where are local variable and parameters stored?  \nGlobal variables?"}, {"answer": "De-allocating first the most recently allocated activation record.\nHigher-order functions.", "question": "What is stack discipline?\nWhat can cause it to fail?"}, {"answer": "The duration a memory location is allocated for a declaration during the run of a program.", "question": "What is lifetime?"}, {"answer": "No, a variable my be hidden, or have a hole in its scope, if a nested block declares a variable of the same name.", "question": "Does lifetime coincide with scope?"}, {"answer": "A function returns a value, a procedure does not.  A function may have side effects, a procedure has only side effects and is a statement, not an expression.", "question": "What is the difference between a function and a procedure?"}, {"answer": "1) Time of evaluation\n2) Location of storage", "question": "What are the two main distinctions between parameter passing mechanisms?"}, {"answer": "Pass-by-reference \u2013 pass the L-value (address) of the parameter\nPass-by-value \u2013 pass the R-value (contents of address) of the parameter\n(there are other mechanisms)", "question": "What are the two most common non-lazy methods (evaluate the actual parameter before executing the function body)?"}, {"answer": "1) Side Effects \u2013 pass-by-ref may alter values outside the function\n2) Aliasing \u2013 pass-by-ref two names may refer to same object (memory)\n3) Efficiency \u2013 pass-by-value inefficient for large data structures", "question": "What three things are important between pass-by-value and pass-by-reference?"}, {"answer": "Static Scope: find in closest enclosing block of program text. (most languages)\nDynamic Scope: find in most recent activation record. (think exceptions/stack trace)", "question": "What are the two main rules for finding a global variable?"}, {"answer": "When all recursive calls in a function are tail calls, i.e. no computations afterward.\nThe same activation record can be used and the function can be compiled into an iterative loop.", "question": "What is tail recursion?\nWhat is its advantage?"}, {"answer": "1) Functions declared within any scope.\n2) Functions passed as arguments.\n3) Functions returned as results.", "question": "What three things define a language as having first-class functions?"}, {"answer": "A closure", "question": "In languages with first-class functions and static sope, what general represents a function value?"}, {"answer": "A pair consisting of a pointer to the function code and a pointer to the activation record.", "question": "What is a closure?"}, {"answer": "They both combine data with code for functions.", "question": "How are closures related to objects?"}, {"answer": "Higher levels pass handlers into lower levels which are called when the lower level needs to notify the higher level of something. (Callbacks/Events?)", "question": "How can you construct a system using function passing and upcalls (function call up the stack)?"}, {"answer": "During the upward funarg problem, when functions are returned as results, since the activation record can\u2019t be deallocated.  During downward funarg, statck discipline still exists but the stack is a tree.", "question": "When does stack discipline break down for higher-order functions?"}, {"answer": "Go To", "question": "What is considered harmful?"}, {"answer": "1) Group code into logical blocks.\n2) Avoid explicit jumps, except for function returns.\n3) Do not (can not) jump into the middle of a block or function", "question": "In modern programming style, what three things help avoid spaghetti code?"}, {"answer": "if \u2026 then \u2026 else \u2026 end\nwhile \u2026 do \u2026 end\nfor \u2026 { \u2026 }\ncase \u2026", "question": "What are four constructs that help to structure jumps?"}, {"answer": "An exception.", "question": "What proveds a structured jump o leave a construct such as a block or function?"}, {"answer": "raising or throwing\nhandling or catching", "question": "What do you call creating an exception?\nWhat about dealing with an exceptions?"}, {"answer": "Dynamic scoping", "question": "What rule determines the correct handler for an exception? "}, {"answer": "A programming technique based on higher order functions.  Related to upcall and callback functions.", "question": "What is continuations?"}], "title": "Concepts in Prog Langs - Part 2"}